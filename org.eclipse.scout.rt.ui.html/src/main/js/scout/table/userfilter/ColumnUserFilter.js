/*
 * Copyright (c) 2014-2018 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 */
import {strings} from '../../index';
import {TableUserFilter} from '../../index';
import {EventSupport} from '../../index';
import {TableMatrix} from '../../index';
import {comparators} from '../../index';

export default class ColumnUserFilter extends TableUserFilter {

constructor() {
  super();
  this.filterType = ColumnUserFilter.TYPE;
  this.events = new EventSupport();

  /**
   * This property is used to check early whether or not this filter can produce filter-fields.
   * Set this property to true in your sub-class, if it creates filter fields.
   */
  this.hasFilterFields = false;

  /**
   * array of (normalized) key, text composite
   */
  this.availableValues = [];

  /**
   * array of (normalized) keys
   */
  this.selectedValues = [];
}


static TYPE = 'column';

axisGroup() {
  return TableMatrix.NumberGroup.COUNT;
}

calculate() {
  var containsSelectedValue, reorderAxis;

  this.matrix = new TableMatrix(this.table, this.session);
  this.matrix.addData(this.column, TableMatrix.NumberGroup.COUNT);
  this.xAxis = this.matrix.addAxis(this.column, this.axisGroup());
  var cube = this.matrix.calculate();

  this.selectedValues.forEach(function(selectedValue) {
    containsSelectedValue = false;
    if (this._useTextInsteadOfNormValue(selectedValue)) {
      // selected value was not normalized -> normalize
      selectedValue = this.xAxis.norm(selectedValue);
    }
    this.xAxis.some(function(key) {
      if (key === selectedValue) {
        containsSelectedValue = true;
        return true;
      }
    }, this);

    if (!containsSelectedValue) {
      this.xAxis.push(selectedValue);
      reorderAxis = true;
    }
  }, this);

  if (reorderAxis) {
    this.xAxis.reorder();
  }

  var text, displayKey, cubeValue, iconId;
  this.availableValues = [];
  this.xAxis.forEach(function(key) {
    displayKey = key;
    text = this.xAxis.format(key);
    iconId = null;
    if (this._useTextInsteadOfNormValue(key)) {
      displayKey = text;
    }
    if (key !== null && this.xAxis.textIsIcon) {
      // Only display icon if textIsIcon (still display empty text if key is null)
      iconId = text;
      text = null;
    }
    cubeValue = cube.getValue([key]);
    this.availableValues.push({
      key: displayKey,
      text: text,
      iconId: iconId,
      htmlEnabled: false,
      cssClass: null,
      count: cubeValue ? cubeValue[0] : 0
    });
  }, this);
}

/**
 * In case of text columns, the normalized key generated by the matrix is not deterministic,
 * it depends on the table data -> use the text. In the other cases it is possible to use the
 * normalized key which has the advantage that it is locale independent.
 */
_useTextInsteadOfNormValue(value) {
  return false;
}

/**
 * @override TableUserFilter.js
 */
createFilterAddedEventData() {
  var data = super.createFilterAddedEventData();
  data.columnId = this.column.id;
  data.selectedValues = this.selectedValues;
  return data;
}

createFilterRemovedEventData() {
  var data = super.createFilterRemovedEventData();
  data.columnId = this.column.id;
  return data;
}

createLabel() {
  if (this.column.headerHtmlEnabled) {
    var plainText = strings.plainText(this.column.text);
    return plainText.replace(/\n/g, ' ');
  }
  return this.column.text || '';
}

createKey() {
  return this.column.id;
}

accept(row) {
  if (!this.xAxis) {
    // Lazy calculation. It is not possible on init, because the table is not rendered yet.
    this.calculate();
  }
  var
    acceptByTable = true,
    acceptByFields = true,
    key = this.column.cellValueOrTextForCalculation(row),
    normKey = this.xAxis.norm(key);

  if (this._useTextInsteadOfNormValue(normKey)) {
    normKey = this.xAxis.format(normKey);
  }
  if (this.tableFilterActive()) {
    acceptByTable = this.selectedValues.indexOf(normKey) > -1;
  }
  if (this.fieldsFilterActive()) {
    acceptByFields = this.acceptByFields(key, normKey, row);
  }

  return acceptByTable && acceptByFields;
}

filterActive() {
  return this.tableFilterActive() || this.fieldsFilterActive();
}

tableFilterActive() {
  return this.selectedValues.length > 0;
}

triggerFilterFieldsChanged(event) {
  this.events.trigger('filterFieldsChanged', event);
}

on(type, func) {
  this.events.on(type, func);
}

off(type, func) {
  this.events.off(type, func);
}

/**
 * Returns whether or not the given key is accepted by the filter-fields in their current state.
 * The default impl. returns true.
 */
acceptByFields(key, normKey, row) {
  return true;
}

/**
 * Returns whether or not filter-fields have an effect on the column-filter in their current state.
 * The default impl. returns false.
 */
fieldsFilterActive() {
  return false;
}

/**
 * Adds filter fields for this type of column filter.
 * The default impl. adds no fields.
 *
 * @param groupBox FilterFieldsGroupBox
 */
addFilterFields(groupBox) {
  // NOP
}

/**
 * Called after filter group-box has been rendered. Gives the filter impl. a chance to
 * modify the rendered fields. The default impl. does nothing.
 */
modifyFilterFields() {
  // NOP
}

/**
 * Returns the title displayed above the filter fields.
 * The default impl. returns a null value, which means the title is not displayed.
 */
filterFieldsTitle() {
  return null;
}

createComparator() {
  return comparators.NUMERIC;
}
}
