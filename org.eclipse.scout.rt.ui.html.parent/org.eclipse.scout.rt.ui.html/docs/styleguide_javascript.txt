+---------------------------------+
| BSI JavaScript Style Guide      |
+---------------------------------+

Als Basis dient der Google JavaScript StyleGuide:
https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml


### Variablen

- Variablen wenn moeglich immer am Anfang der Funktion deklarieren. Variablen am
  Anfang zu Deklarieren ist good practice, denn die JS-Engine macht das bei der
  Ausfuehrung sowieso(variable hoisting).
- Pro 'var' Anweisung dürfen mehrere Variablen deklariert und auch initialisiert
  werden. Komplexe Initialisierung soll aber auf einer separaten Zeile notiert
  werden.
- Grundsätzlich ist eine kompakte Darstellung erwünscht, die Lesbarkeit soll
  aber nicht darunter leiden.


Beispiele:

NOK:                           OK:
-------------------------------------------------------------------------
var x = (y > 0 ? 1 : 2), y = $('h1').children('.myClass').first().text();

                               var x, y = 3;

                               var x = 4,
                                 y = 3,
                                 value = $('h1').text();


Links:
- http://benalman.com/news/2012/05/multiple-var-statements-javascript/


### Visibility
Wir verwenden _ als Prefix für private Members einer Klasse. Solche Members dürfen von aussen nicht zugegriffen werden (Ausnahme: in Tests/Specs)


### Pruefen, ob eine Variable oder ein Property existiert

Varianten fuer Properties:
  1. if (obj.x === undefined)
  2. if (typeof obj.x === 'undefined')
  3. if (obj.hasOwnProperty('x'))

Varianten fuer Variablen:
  1. if (y === undefined)
  2. if (typeof y === 'undefined')

Bewertung:
- #1 funktioniert bei Properties, aber nicht bei Variablen. Wenn die Variable nicht
  definiert ist, gibt es eine Exception. Weiteres (theoretisches) Problem: Jemand
  koennte die Variable 'undefined' umdefinieren. (wir stellen jedoch im scout-template.js
  sicher, dass dies nicht geschehen kann).
- #2 funktioniert immer. Bei Properties werden auch diejenigen der Protoypen
  beruecksichtigt.
- #3 kann sinnvoll sein, denn es schaut _nicht_ beim Prototyp nach. Allerdings scheint
  es extrem langsam zu sein, darum besser nicht verwenden.

--> Wir verwenden grundsätzlich Variante #1. Exceptions die durch nicht deklarierte
    Variablen verursacht werden sind Programmierfehler.

Links:
- http://stackoverflow.com/questions/4725603
- http://stackoverflow.com/questions/17150396
- http://jsperf.com/hasownproperty-vs-in/2


### Gleichheit pruefen

Empfehlung: Immer === verwenden, es sei denn, man moechte explizit Type Coercion
verwenden bzw. unterstuetzen. Ansonsten ist es besser, dass der Code auch mit dem
strikten Vergleich funktioniert (und nicht nur "zufaellig" wegen JS-Type-Magie).

Performance scheint nur eine untergeordnete Rolle zu spielen:
http://www.adequatelygood.com/Performance-of-vs-.html


### Exceptions werfen

Man kann in JS grundsaetzlich beliebige Objekte werfen. Es sollte aber immer ein Error-
Objekt geworfen werden, nie nur ein String. Das Problem mit Strings ist, dass nicht
alle "Faenger" damit umgehen konnen. Jasmine z.B. zeigt dann nur "undefined: undefined"
als Meldung an, was ueberhaupt nicht hilfreich ist. IE hat angeblich auch Probleme damit.
FireFox zeigt keine Line-Number-Info an ohne Error Object.

NOK:                           OK:
-------------------------------------------------------------------------
throw 'This is an error';      throw new Error('This is an error');

Links:
http://www.nczonline.net/blog/2009/03/10/the-art-of-throwing-javascript-errors-part-2/
http://stackoverflow.com/questions/11502052/throwing-strings-instead-of-errors


### Strings

In JavaScript fuer Strings immer einheitlich ' als Begrenzer verwenden.

Ausnahme: Wenn innerhalb des Strings sehr viele Apostrophe vorkommen, kann man die
Anfuehrungszeichen umkehren, damit man sich das Escapen sparen kann.

Und: In einem JSON-Objekt _muessen_ fuer Strings " verwendet werden! Aber Achtung, wenn man
ein JS-Objekt im Code von Hand erzeugt, dann ist noch lange kein JSON! Trotzdem kann man da,
wenn man moechte, doppelte Anfuehrungszeichen verwenden.

Es gibt keinen wirklich triftigen Grund, ausser dass es besser ist, wenn nicht im ganzen
Code beide Arten von Anfuehrungszeichen durcheinander verwendet werden. Fuer das Erzeugen
von HTML-Code mit Attributen ist es ausserdem praktisch, wenn die doppelten
Anfuehrungszeichen nicht escaped werden muessen.

Beispiele:
var x = 'This is a string.';
var y = '<div id="' + model.id + '" class="row selected">That\'s it!</div>';
var z = "That's it!";
var obj = {
  "id": 123;
  'name': 'simple object';
};
var jsonResponse = '{ "id": 123, "name": "simple object" }';


### Kommentare

Kommentare immer so:
  // My comment

So nicht:
  //My comment
  /* My comment */


### Overloading

JavaScript kennt kein Ueberladen von Methoden. Allerdings sind Funktionen auch nicht streng
typisiert, somit kann eine dynamische Anzahl Argumente uebergeben werden, mit unterschiedlichen
Typen. Ein Pattern um Overloading zu implementieren ist wie folgt. Agenommen die Methode 'setSize'
soll mit 2 Numbers und mit einem Dimension Objekt aufgerufen werden koennen:

  obj.setSize(6, 7);

  obj.setSize(new Dimension(6, 7));

Die Implementierung von setSize ist wie folgt:

  setSize = function(vararg, height) {
    if (vararg instanceof Dimension) {
      this.width = vararg.width;
      this.height = vararg.height;
    } else {
      this.width = vararg;
      this.height = height;
    }
  };

Bei Konstruktoren moechte man oft auch einen Default-Konstruktor, das Beispiel oben liesse sich
dann wie folgt erweitern:

      this.width = vararg || 0;
      this.height = height || 0;

Für Konstruktoren mit vielen Parametern bietet es sich an, ein einzelnes Objekt als Parameter zu verwenden. Wir nennen dieses Objekt "options".
Dies macht die Erzeugung eines Objektes einiges übersichtlicher:

scout.MyObject = function(options) {
  options = options || {};
  var param1 = options.param1 || 'default';
  var param2 = options.param2 !== undefined ? options.param2 : true
}

var obj = new scout.MyObject({
  param1: 'abc',
  param2: false
}

Achtung: Falls '', 0 oder false als Werte erlaubt sind, kann || nicht verwendet werden -> ? Notation verwenden
Alternativ kann auch $.extend eingesetzt werden.

### Properties
Wir erzeugen keine getter und setter für einfache Properties (ohne Logik). Man soll direkt auf die Variable zugreifen. Hauptgrund -> Code wird nicht unnötig aufgeblasen.
